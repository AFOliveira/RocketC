Terminals unused in grammar

    ERROR
    IF
    ELSEIF
    ELSE
    SWITCH
    CASE
    DEFAULT
    BREAK
    AUTO
    CONTINUE
    EXTERN
    GOTO
    LONG
    ENUM
    REGISTER
    SHORT
    SIZEOF
    STATIC
    SIGNED
    UNION
    UNSIGNED
    VOLATILE
    FNUM
    STRINGliteral
    ASSIGN
    LEFT_BRACKET
    RIGHT_BRACKET
    TERNARY
    COLON
    COMMA
    INCREMENT
    DECREMENT
    BITWISE_AND
    BITWISE_OR
    BITWISE_NOT
    BITWISE_XOR
    LOGICAL_NOT
    LOGICAL_AND
    LOGICAL_OR
    EQUAL
    NOT_EQUAL
    LESS_THAN
    GREATER_THAN
    LESS_THAN_OR_EQUAL
    GREATER_THAN_OR_EQUAL
    RIGHT_SHIFT
    LEFT_SHIFT
    PLUS_ASSIGN
    MINUS_ASSIGN
    MODULO
    LEFT_SHIFT_ASSIGN
    RIGHT_SHIFT_ASSIGN
    BITWISE_AND_ASSIGN
    BITWISE_OR_ASSIGN
    BITWISE_XOR_ASSIGN
    MULTIPLY_ASSIGN
    DIVIDE_ASSIGN
    MODULUS_ASSIGN
    PREPROCESSOR
    ARROW
    DEFINE
    CONSTANT
    POINTER
    ADDRESS_OF
    OTHER


Rules useless in parser due to conflicts

   31 while_stmt: ε


State 0 conflicts: 14 shift/reduce, 2 reduce/reduce
State 2 conflicts: 1 reduce/reduce
State 14 conflicts: 14 shift/reduce, 2 reduce/reduce
State 16 conflicts: 1 reduce/reduce
State 39 conflicts: 1 reduce/reduce
State 44 conflicts: 14 shift/reduce, 2 reduce/reduce
State 55 conflicts: 14 shift/reduce, 19 reduce/reduce
State 56 conflicts: 14 shift/reduce, 2 reduce/reduce
State 57 conflicts: 14 shift/reduce, 3 reduce/reduce
State 60 conflicts: 14 shift/reduce, 2 reduce/reduce
State 61 conflicts: 14 shift/reduce, 2 reduce/reduce
State 67 conflicts: 2 reduce/reduce


Grammar

    0 $accept: prog $end

    1 prog: stmts endfile

    2 stmts: ε
    3      | stmt SEMI stmts
    4      | stmt SEMI endofline stmts
    5      | stmt SEMI EOL stmts
    6      | stmts stmt SEMI

    7 stmt: if_stmt
    8     | while_stmt
    9     | do_stmt
   10     | for_stmt
   11     | return_stmt
   12     | endofline
   13     | declaration_stmt
   14     | compound_stmt
   15     | expr

   16 declaration_stmt: type ID
   17                 | type arith_expr

   18 compound_stmt: LEFT_BRACE stmts RIGHT_BRACE

   19 expr: arith_expr

   20 arith_expr: NUM op NUM
   21           | ID op ID
   22           | ID op NUM
   23           | NUM op ID

   24 op: PLUS
   25   | MINUS
   26   | TIMES
   27   | OVER
   28   | PERCENT

   29 if_stmt: ε

   30 return_stmt: RETURN expr

   31 while_stmt: ε

   32 do_stmt: DO stmt WHILE LPAREN expr RPAREN

   33 for_stmt: FOR LPAREN expr SEMI expr SEMI expr RPAREN stmt

   34 endofline: EOL

   35 endfile: ENDFILE

   36 type: INT
   37     | FLOAT
   38     | DOUBLE
   39     | CHAR
   40     | VOID
   41     | STRUCT
   42     | TYPEDEF


Terminals, with rules where they appear

    $end (0) 0
    error (256)
    ENDFILE (258) 35
    ERROR (259)
    EOL (260) 5 34
    IF (261)
    ELSEIF (262)
    ELSE (263)
    DO (264) 32
    WHILE (265) 32
    FOR (266) 33
    SWITCH (267)
    CASE (268)
    DEFAULT (269)
    RETURN (270) 30
    BREAK (271)
    INT (272) 36
    FLOAT (273) 37
    DOUBLE (274) 38
    CHAR (275) 39
    VOID (276) 40
    STRUCT (277) 41
    TYPEDEF (278) 42
    AUTO (279)
    CONTINUE (280)
    EXTERN (281)
    GOTO (282)
    LONG (283)
    ENUM (284)
    REGISTER (285)
    SHORT (286)
    SIZEOF (287)
    STATIC (288)
    SIGNED (289)
    UNION (290)
    UNSIGNED (291)
    VOLATILE (292)
    NUM <intval> (293) 20 22 23
    ID <identifier> (294) 16 21 22 23
    FNUM <floatval> (295)
    STRINGliteral <strval> (296)
    ASSIGN (297)
    PLUS (298) 24
    MINUS (299) 25
    TIMES (300) 26
    OVER (301) 27
    PERCENT (302) 28
    LPAREN (303) 32 33
    RPAREN (304) 32 33
    LEFT_BRACE (305) 18
    RIGHT_BRACE (306) 18
    LEFT_BRACKET (307)
    RIGHT_BRACKET (308)
    TERNARY (309)
    SEMI (310) 3 4 5 6 33
    COLON (311)
    COMMA (312)
    INCREMENT (313)
    DECREMENT (314)
    BITWISE_AND (315)
    BITWISE_OR (316)
    BITWISE_NOT (317)
    BITWISE_XOR (318)
    LOGICAL_NOT (319)
    LOGICAL_AND (320)
    LOGICAL_OR (321)
    EQUAL (322)
    NOT_EQUAL (323)
    LESS_THAN (324)
    GREATER_THAN (325)
    LESS_THAN_OR_EQUAL (326)
    GREATER_THAN_OR_EQUAL (327)
    RIGHT_SHIFT (328)
    LEFT_SHIFT (329)
    PLUS_ASSIGN (330)
    MINUS_ASSIGN (331)
    MODULO (332)
    LEFT_SHIFT_ASSIGN (333)
    RIGHT_SHIFT_ASSIGN (334)
    BITWISE_AND_ASSIGN (335)
    BITWISE_OR_ASSIGN (336)
    BITWISE_XOR_ASSIGN (337)
    MULTIPLY_ASSIGN (338)
    DIVIDE_ASSIGN (339)
    MODULUS_ASSIGN (340)
    PREPROCESSOR (341)
    ARROW (342)
    DEFINE (343)
    CONSTANT (344)
    POINTER (345)
    ADDRESS_OF (346)
    OTHER (347)


Nonterminals, with rules where they appear

    $accept (93)
        on left: 0
    prog (94)
        on left: 1
        on right: 0
    stmts (95)
        on left: 2 3 4 5 6
        on right: 1 3 4 5 6 18
    stmt (96)
        on left: 7 8 9 10 11 12 13 14 15
        on right: 3 4 5 6 32 33
    declaration_stmt (97)
        on left: 16 17
        on right: 13
    compound_stmt (98)
        on left: 18
        on right: 14
    expr (99)
        on left: 19
        on right: 15 30 32 33
    arith_expr (100)
        on left: 20 21 22 23
        on right: 17 19
    op (101)
        on left: 24 25 26 27 28
        on right: 20 21 22 23
    if_stmt (102)
        on left: 29
        on right: 7
    return_stmt (103)
        on left: 30
        on right: 11
    while_stmt (104)
        on left: 31
        on right: 8
    do_stmt (105)
        on left: 32
        on right: 9
    for_stmt (106)
        on left: 33
        on right: 10
    endofline (107)
        on left: 34
        on right: 4 12
    endfile (108)
        on left: 35
        on right: 1
    type (109)
        on left: 36 37 38 39 40 41 42
        on right: 16 17


State 0

    0 $accept: • prog $end

    EOL         shift, and go to state 1
    DO          shift, and go to state 2
    FOR         shift, and go to state 3
    RETURN      shift, and go to state 4
    INT         shift, and go to state 5
    FLOAT       shift, and go to state 6
    DOUBLE      shift, and go to state 7
    CHAR        shift, and go to state 8
    VOID        shift, and go to state 9
    STRUCT      shift, and go to state 10
    TYPEDEF     shift, and go to state 11
    NUM         shift, and go to state 12
    ID          shift, and go to state 13
    LEFT_BRACE  shift, and go to state 14

    EOL         [reduce using rule 2 (stmts)]
    DO          [reduce using rule 2 (stmts)]
    FOR         [reduce using rule 2 (stmts)]
    RETURN      [reduce using rule 2 (stmts)]
    INT         [reduce using rule 2 (stmts)]
    FLOAT       [reduce using rule 2 (stmts)]
    DOUBLE      [reduce using rule 2 (stmts)]
    CHAR        [reduce using rule 2 (stmts)]
    VOID        [reduce using rule 2 (stmts)]
    STRUCT      [reduce using rule 2 (stmts)]
    TYPEDEF     [reduce using rule 2 (stmts)]
    NUM         [reduce using rule 2 (stmts)]
    ID          [reduce using rule 2 (stmts)]
    LEFT_BRACE  [reduce using rule 2 (stmts)]
    SEMI        reduce using rule 2 (stmts)
    SEMI        [reduce using rule 29 (if_stmt)]
    SEMI        [reduce using rule 31 (while_stmt)]
    $default    reduce using rule 2 (stmts)

    prog              go to state 15
    stmts             go to state 16
    stmt              go to state 17
    declaration_stmt  go to state 18
    compound_stmt     go to state 19
    expr              go to state 20
    arith_expr        go to state 21
    if_stmt           go to state 22
    return_stmt       go to state 23
    while_stmt        go to state 24
    do_stmt           go to state 25
    for_stmt          go to state 26
    endofline         go to state 27
    type              go to state 28


State 1

   34 endofline: EOL •

    $default  reduce using rule 34 (endofline)


State 2

   32 do_stmt: DO • stmt WHILE LPAREN expr RPAREN

    EOL         shift, and go to state 1
    DO          shift, and go to state 2
    FOR         shift, and go to state 3
    RETURN      shift, and go to state 4
    INT         shift, and go to state 5
    FLOAT       shift, and go to state 6
    DOUBLE      shift, and go to state 7
    CHAR        shift, and go to state 8
    VOID        shift, and go to state 9
    STRUCT      shift, and go to state 10
    TYPEDEF     shift, and go to state 11
    NUM         shift, and go to state 12
    ID          shift, and go to state 13
    LEFT_BRACE  shift, and go to state 14

    WHILE     reduce using rule 29 (if_stmt)
    WHILE     [reduce using rule 31 (while_stmt)]
    $default  reduce using rule 29 (if_stmt)

    stmt              go to state 29
    declaration_stmt  go to state 18
    compound_stmt     go to state 19
    expr              go to state 20
    arith_expr        go to state 21
    if_stmt           go to state 22
    return_stmt       go to state 23
    while_stmt        go to state 24
    do_stmt           go to state 25
    for_stmt          go to state 26
    endofline         go to state 27
    type              go to state 28


State 3

   33 for_stmt: FOR • LPAREN expr SEMI expr SEMI expr RPAREN stmt

    LPAREN  shift, and go to state 30


State 4

   30 return_stmt: RETURN • expr

    NUM  shift, and go to state 12
    ID   shift, and go to state 13

    expr        go to state 31
    arith_expr  go to state 21


State 5

   36 type: INT •

    $default  reduce using rule 36 (type)


State 6

   37 type: FLOAT •

    $default  reduce using rule 37 (type)


State 7

   38 type: DOUBLE •

    $default  reduce using rule 38 (type)


State 8

   39 type: CHAR •

    $default  reduce using rule 39 (type)


State 9

   40 type: VOID •

    $default  reduce using rule 40 (type)


State 10

   41 type: STRUCT •

    $default  reduce using rule 41 (type)


State 11

   42 type: TYPEDEF •

    $default  reduce using rule 42 (type)


State 12

   20 arith_expr: NUM • op NUM
   23           | NUM • op ID

    PLUS     shift, and go to state 32
    MINUS    shift, and go to state 33
    TIMES    shift, and go to state 34
    OVER     shift, and go to state 35
    PERCENT  shift, and go to state 36

    op  go to state 37


State 13

   21 arith_expr: ID • op ID
   22           | ID • op NUM

    PLUS     shift, and go to state 32
    MINUS    shift, and go to state 33
    TIMES    shift, and go to state 34
    OVER     shift, and go to state 35
    PERCENT  shift, and go to state 36

    op  go to state 38


State 14

   18 compound_stmt: LEFT_BRACE • stmts RIGHT_BRACE

    EOL         shift, and go to state 1
    DO          shift, and go to state 2
    FOR         shift, and go to state 3
    RETURN      shift, and go to state 4
    INT         shift, and go to state 5
    FLOAT       shift, and go to state 6
    DOUBLE      shift, and go to state 7
    CHAR        shift, and go to state 8
    VOID        shift, and go to state 9
    STRUCT      shift, and go to state 10
    TYPEDEF     shift, and go to state 11
    NUM         shift, and go to state 12
    ID          shift, and go to state 13
    LEFT_BRACE  shift, and go to state 14

    EOL         [reduce using rule 2 (stmts)]
    DO          [reduce using rule 2 (stmts)]
    FOR         [reduce using rule 2 (stmts)]
    RETURN      [reduce using rule 2 (stmts)]
    INT         [reduce using rule 2 (stmts)]
    FLOAT       [reduce using rule 2 (stmts)]
    DOUBLE      [reduce using rule 2 (stmts)]
    CHAR        [reduce using rule 2 (stmts)]
    VOID        [reduce using rule 2 (stmts)]
    STRUCT      [reduce using rule 2 (stmts)]
    TYPEDEF     [reduce using rule 2 (stmts)]
    NUM         [reduce using rule 2 (stmts)]
    ID          [reduce using rule 2 (stmts)]
    LEFT_BRACE  [reduce using rule 2 (stmts)]
    SEMI        reduce using rule 2 (stmts)
    SEMI        [reduce using rule 29 (if_stmt)]
    SEMI        [reduce using rule 31 (while_stmt)]
    $default    reduce using rule 2 (stmts)

    stmts             go to state 39
    stmt              go to state 17
    declaration_stmt  go to state 18
    compound_stmt     go to state 19
    expr              go to state 20
    arith_expr        go to state 21
    if_stmt           go to state 22
    return_stmt       go to state 23
    while_stmt        go to state 24
    do_stmt           go to state 25
    for_stmt          go to state 26
    endofline         go to state 27
    type              go to state 28


State 15

    0 $accept: prog • $end

    $end  shift, and go to state 40


State 16

    1 prog: stmts • endfile
    6 stmts: stmts • stmt SEMI

    ENDFILE     shift, and go to state 41
    EOL         shift, and go to state 1
    DO          shift, and go to state 2
    FOR         shift, and go to state 3
    RETURN      shift, and go to state 4
    INT         shift, and go to state 5
    FLOAT       shift, and go to state 6
    DOUBLE      shift, and go to state 7
    CHAR        shift, and go to state 8
    VOID        shift, and go to state 9
    STRUCT      shift, and go to state 10
    TYPEDEF     shift, and go to state 11
    NUM         shift, and go to state 12
    ID          shift, and go to state 13
    LEFT_BRACE  shift, and go to state 14

    SEMI      reduce using rule 29 (if_stmt)
    SEMI      [reduce using rule 31 (while_stmt)]
    $default  reduce using rule 29 (if_stmt)

    stmt              go to state 42
    declaration_stmt  go to state 18
    compound_stmt     go to state 19
    expr              go to state 20
    arith_expr        go to state 21
    if_stmt           go to state 22
    return_stmt       go to state 23
    while_stmt        go to state 24
    do_stmt           go to state 25
    for_stmt          go to state 26
    endofline         go to state 27
    endfile           go to state 43
    type              go to state 28


State 17

    3 stmts: stmt • SEMI stmts
    4      | stmt • SEMI endofline stmts
    5      | stmt • SEMI EOL stmts

    SEMI  shift, and go to state 44


State 18

   13 stmt: declaration_stmt •

    $default  reduce using rule 13 (stmt)


State 19

   14 stmt: compound_stmt •

    $default  reduce using rule 14 (stmt)


State 20

   15 stmt: expr •

    $default  reduce using rule 15 (stmt)


State 21

   19 expr: arith_expr •

    $default  reduce using rule 19 (expr)


State 22

    7 stmt: if_stmt •

    $default  reduce using rule 7 (stmt)


State 23

   11 stmt: return_stmt •

    $default  reduce using rule 11 (stmt)


State 24

    8 stmt: while_stmt •

    $default  reduce using rule 8 (stmt)


State 25

    9 stmt: do_stmt •

    $default  reduce using rule 9 (stmt)


State 26

   10 stmt: for_stmt •

    $default  reduce using rule 10 (stmt)


State 27

   12 stmt: endofline •

    $default  reduce using rule 12 (stmt)


State 28

   16 declaration_stmt: type • ID
   17                 | type • arith_expr

    NUM  shift, and go to state 12
    ID   shift, and go to state 45

    arith_expr  go to state 46


State 29

   32 do_stmt: DO stmt • WHILE LPAREN expr RPAREN

    WHILE  shift, and go to state 47


State 30

   33 for_stmt: FOR LPAREN • expr SEMI expr SEMI expr RPAREN stmt

    NUM  shift, and go to state 12
    ID   shift, and go to state 13

    expr        go to state 48
    arith_expr  go to state 21


State 31

   30 return_stmt: RETURN expr •

    $default  reduce using rule 30 (return_stmt)


State 32

   24 op: PLUS •

    $default  reduce using rule 24 (op)


State 33

   25 op: MINUS •

    $default  reduce using rule 25 (op)


State 34

   26 op: TIMES •

    $default  reduce using rule 26 (op)


State 35

   27 op: OVER •

    $default  reduce using rule 27 (op)


State 36

   28 op: PERCENT •

    $default  reduce using rule 28 (op)


State 37

   20 arith_expr: NUM op • NUM
   23           | NUM op • ID

    NUM  shift, and go to state 49
    ID   shift, and go to state 50


State 38

   21 arith_expr: ID op • ID
   22           | ID op • NUM

    NUM  shift, and go to state 51
    ID   shift, and go to state 52


State 39

    6 stmts: stmts • stmt SEMI
   18 compound_stmt: LEFT_BRACE stmts • RIGHT_BRACE

    EOL          shift, and go to state 1
    DO           shift, and go to state 2
    FOR          shift, and go to state 3
    RETURN       shift, and go to state 4
    INT          shift, and go to state 5
    FLOAT        shift, and go to state 6
    DOUBLE       shift, and go to state 7
    CHAR         shift, and go to state 8
    VOID         shift, and go to state 9
    STRUCT       shift, and go to state 10
    TYPEDEF      shift, and go to state 11
    NUM          shift, and go to state 12
    ID           shift, and go to state 13
    LEFT_BRACE   shift, and go to state 14
    RIGHT_BRACE  shift, and go to state 53

    SEMI      reduce using rule 29 (if_stmt)
    SEMI      [reduce using rule 31 (while_stmt)]
    $default  reduce using rule 29 (if_stmt)

    stmt              go to state 42
    declaration_stmt  go to state 18
    compound_stmt     go to state 19
    expr              go to state 20
    arith_expr        go to state 21
    if_stmt           go to state 22
    return_stmt       go to state 23
    while_stmt        go to state 24
    do_stmt           go to state 25
    for_stmt          go to state 26
    endofline         go to state 27
    type              go to state 28


State 40

    0 $accept: prog $end •

    $default  accept


State 41

   35 endfile: ENDFILE •

    $default  reduce using rule 35 (endfile)


State 42

    6 stmts: stmts stmt • SEMI

    SEMI  shift, and go to state 54


State 43

    1 prog: stmts endfile •

    $default  reduce using rule 1 (prog)


State 44

    3 stmts: stmt SEMI • stmts
    4      | stmt SEMI • endofline stmts
    5      | stmt SEMI • EOL stmts

    EOL         shift, and go to state 55
    DO          shift, and go to state 2
    FOR         shift, and go to state 3
    RETURN      shift, and go to state 4
    INT         shift, and go to state 5
    FLOAT       shift, and go to state 6
    DOUBLE      shift, and go to state 7
    CHAR        shift, and go to state 8
    VOID        shift, and go to state 9
    STRUCT      shift, and go to state 10
    TYPEDEF     shift, and go to state 11
    NUM         shift, and go to state 12
    ID          shift, and go to state 13
    LEFT_BRACE  shift, and go to state 14

    EOL         [reduce using rule 2 (stmts)]
    DO          [reduce using rule 2 (stmts)]
    FOR         [reduce using rule 2 (stmts)]
    RETURN      [reduce using rule 2 (stmts)]
    INT         [reduce using rule 2 (stmts)]
    FLOAT       [reduce using rule 2 (stmts)]
    DOUBLE      [reduce using rule 2 (stmts)]
    CHAR        [reduce using rule 2 (stmts)]
    VOID        [reduce using rule 2 (stmts)]
    STRUCT      [reduce using rule 2 (stmts)]
    TYPEDEF     [reduce using rule 2 (stmts)]
    NUM         [reduce using rule 2 (stmts)]
    ID          [reduce using rule 2 (stmts)]
    LEFT_BRACE  [reduce using rule 2 (stmts)]
    SEMI        reduce using rule 2 (stmts)
    SEMI        [reduce using rule 29 (if_stmt)]
    SEMI        [reduce using rule 31 (while_stmt)]
    $default    reduce using rule 2 (stmts)

    stmts             go to state 56
    stmt              go to state 17
    declaration_stmt  go to state 18
    compound_stmt     go to state 19
    expr              go to state 20
    arith_expr        go to state 21
    if_stmt           go to state 22
    return_stmt       go to state 23
    while_stmt        go to state 24
    do_stmt           go to state 25
    for_stmt          go to state 26
    endofline         go to state 57
    type              go to state 28


State 45

   16 declaration_stmt: type ID •
   21 arith_expr: ID • op ID
   22           | ID • op NUM

    PLUS     shift, and go to state 32
    MINUS    shift, and go to state 33
    TIMES    shift, and go to state 34
    OVER     shift, and go to state 35
    PERCENT  shift, and go to state 36

    $default  reduce using rule 16 (declaration_stmt)

    op  go to state 38


State 46

   17 declaration_stmt: type arith_expr •

    $default  reduce using rule 17 (declaration_stmt)


State 47

   32 do_stmt: DO stmt WHILE • LPAREN expr RPAREN

    LPAREN  shift, and go to state 58


State 48

   33 for_stmt: FOR LPAREN expr • SEMI expr SEMI expr RPAREN stmt

    SEMI  shift, and go to state 59


State 49

   20 arith_expr: NUM op NUM •

    $default  reduce using rule 20 (arith_expr)


State 50

   23 arith_expr: NUM op ID •

    $default  reduce using rule 23 (arith_expr)


State 51

   22 arith_expr: ID op NUM •

    $default  reduce using rule 22 (arith_expr)


State 52

   21 arith_expr: ID op ID •

    $default  reduce using rule 21 (arith_expr)


State 53

   18 compound_stmt: LEFT_BRACE stmts RIGHT_BRACE •

    $default  reduce using rule 18 (compound_stmt)


State 54

    6 stmts: stmts stmt SEMI •

    $default  reduce using rule 6 (stmts)


State 55

    5 stmts: stmt SEMI EOL • stmts
   34 endofline: EOL •

    EOL         shift, and go to state 1
    DO          shift, and go to state 2
    FOR         shift, and go to state 3
    RETURN      shift, and go to state 4
    INT         shift, and go to state 5
    FLOAT       shift, and go to state 6
    DOUBLE      shift, and go to state 7
    CHAR        shift, and go to state 8
    VOID        shift, and go to state 9
    STRUCT      shift, and go to state 10
    TYPEDEF     shift, and go to state 11
    NUM         shift, and go to state 12
    ID          shift, and go to state 13
    LEFT_BRACE  shift, and go to state 14

    ENDFILE      reduce using rule 2 (stmts)
    ENDFILE      [reduce using rule 34 (endofline)]
    EOL          [reduce using rule 2 (stmts)]
    EOL          [reduce using rule 34 (endofline)]
    DO           [reduce using rule 2 (stmts)]
    DO           [reduce using rule 34 (endofline)]
    FOR          [reduce using rule 2 (stmts)]
    FOR          [reduce using rule 34 (endofline)]
    RETURN       [reduce using rule 2 (stmts)]
    RETURN       [reduce using rule 34 (endofline)]
    INT          [reduce using rule 2 (stmts)]
    INT          [reduce using rule 34 (endofline)]
    FLOAT        [reduce using rule 2 (stmts)]
    FLOAT        [reduce using rule 34 (endofline)]
    DOUBLE       [reduce using rule 2 (stmts)]
    DOUBLE       [reduce using rule 34 (endofline)]
    CHAR         [reduce using rule 2 (stmts)]
    CHAR         [reduce using rule 34 (endofline)]
    VOID         [reduce using rule 2 (stmts)]
    VOID         [reduce using rule 34 (endofline)]
    STRUCT       [reduce using rule 2 (stmts)]
    STRUCT       [reduce using rule 34 (endofline)]
    TYPEDEF      [reduce using rule 2 (stmts)]
    TYPEDEF      [reduce using rule 34 (endofline)]
    NUM          [reduce using rule 2 (stmts)]
    NUM          [reduce using rule 34 (endofline)]
    ID           [reduce using rule 2 (stmts)]
    ID           [reduce using rule 34 (endofline)]
    LEFT_BRACE   [reduce using rule 2 (stmts)]
    LEFT_BRACE   [reduce using rule 34 (endofline)]
    RIGHT_BRACE  reduce using rule 2 (stmts)
    RIGHT_BRACE  [reduce using rule 34 (endofline)]
    SEMI         reduce using rule 2 (stmts)
    SEMI         [reduce using rule 29 (if_stmt)]
    SEMI         [reduce using rule 31 (while_stmt)]
    SEMI         [reduce using rule 34 (endofline)]
    $default     reduce using rule 2 (stmts)

    stmts             go to state 60
    stmt              go to state 17
    declaration_stmt  go to state 18
    compound_stmt     go to state 19
    expr              go to state 20
    arith_expr        go to state 21
    if_stmt           go to state 22
    return_stmt       go to state 23
    while_stmt        go to state 24
    do_stmt           go to state 25
    for_stmt          go to state 26
    endofline         go to state 27
    type              go to state 28


State 56

    3 stmts: stmt SEMI stmts •
    6      | stmts • stmt SEMI

    EOL         shift, and go to state 1
    DO          shift, and go to state 2
    FOR         shift, and go to state 3
    RETURN      shift, and go to state 4
    INT         shift, and go to state 5
    FLOAT       shift, and go to state 6
    DOUBLE      shift, and go to state 7
    CHAR        shift, and go to state 8
    VOID        shift, and go to state 9
    STRUCT      shift, and go to state 10
    TYPEDEF     shift, and go to state 11
    NUM         shift, and go to state 12
    ID          shift, and go to state 13
    LEFT_BRACE  shift, and go to state 14

    EOL         [reduce using rule 3 (stmts)]
    DO          [reduce using rule 3 (stmts)]
    FOR         [reduce using rule 3 (stmts)]
    RETURN      [reduce using rule 3 (stmts)]
    INT         [reduce using rule 3 (stmts)]
    FLOAT       [reduce using rule 3 (stmts)]
    DOUBLE      [reduce using rule 3 (stmts)]
    CHAR        [reduce using rule 3 (stmts)]
    VOID        [reduce using rule 3 (stmts)]
    STRUCT      [reduce using rule 3 (stmts)]
    TYPEDEF     [reduce using rule 3 (stmts)]
    NUM         [reduce using rule 3 (stmts)]
    ID          [reduce using rule 3 (stmts)]
    LEFT_BRACE  [reduce using rule 3 (stmts)]
    SEMI        reduce using rule 3 (stmts)
    SEMI        [reduce using rule 29 (if_stmt)]
    SEMI        [reduce using rule 31 (while_stmt)]
    $default    reduce using rule 3 (stmts)

    stmt              go to state 42
    declaration_stmt  go to state 18
    compound_stmt     go to state 19
    expr              go to state 20
    arith_expr        go to state 21
    if_stmt           go to state 22
    return_stmt       go to state 23
    while_stmt        go to state 24
    do_stmt           go to state 25
    for_stmt          go to state 26
    endofline         go to state 27
    type              go to state 28


State 57

    4 stmts: stmt SEMI endofline • stmts
   12 stmt: endofline •

    EOL         shift, and go to state 1
    DO          shift, and go to state 2
    FOR         shift, and go to state 3
    RETURN      shift, and go to state 4
    INT         shift, and go to state 5
    FLOAT       shift, and go to state 6
    DOUBLE      shift, and go to state 7
    CHAR        shift, and go to state 8
    VOID        shift, and go to state 9
    STRUCT      shift, and go to state 10
    TYPEDEF     shift, and go to state 11
    NUM         shift, and go to state 12
    ID          shift, and go to state 13
    LEFT_BRACE  shift, and go to state 14

    EOL         [reduce using rule 2 (stmts)]
    DO          [reduce using rule 2 (stmts)]
    FOR         [reduce using rule 2 (stmts)]
    RETURN      [reduce using rule 2 (stmts)]
    INT         [reduce using rule 2 (stmts)]
    FLOAT       [reduce using rule 2 (stmts)]
    DOUBLE      [reduce using rule 2 (stmts)]
    CHAR        [reduce using rule 2 (stmts)]
    VOID        [reduce using rule 2 (stmts)]
    STRUCT      [reduce using rule 2 (stmts)]
    TYPEDEF     [reduce using rule 2 (stmts)]
    NUM         [reduce using rule 2 (stmts)]
    ID          [reduce using rule 2 (stmts)]
    LEFT_BRACE  [reduce using rule 2 (stmts)]
    SEMI        reduce using rule 2 (stmts)
    SEMI        [reduce using rule 12 (stmt)]
    SEMI        [reduce using rule 29 (if_stmt)]
    SEMI        [reduce using rule 31 (while_stmt)]
    $default    reduce using rule 2 (stmts)

    stmts             go to state 61
    stmt              go to state 17
    declaration_stmt  go to state 18
    compound_stmt     go to state 19
    expr              go to state 20
    arith_expr        go to state 21
    if_stmt           go to state 22
    return_stmt       go to state 23
    while_stmt        go to state 24
    do_stmt           go to state 25
    for_stmt          go to state 26
    endofline         go to state 27
    type              go to state 28


State 58

   32 do_stmt: DO stmt WHILE LPAREN • expr RPAREN

    NUM  shift, and go to state 12
    ID   shift, and go to state 13

    expr        go to state 62
    arith_expr  go to state 21


State 59

   33 for_stmt: FOR LPAREN expr SEMI • expr SEMI expr RPAREN stmt

    NUM  shift, and go to state 12
    ID   shift, and go to state 13

    expr        go to state 63
    arith_expr  go to state 21


State 60

    5 stmts: stmt SEMI EOL stmts •
    6      | stmts • stmt SEMI

    EOL         shift, and go to state 1
    DO          shift, and go to state 2
    FOR         shift, and go to state 3
    RETURN      shift, and go to state 4
    INT         shift, and go to state 5
    FLOAT       shift, and go to state 6
    DOUBLE      shift, and go to state 7
    CHAR        shift, and go to state 8
    VOID        shift, and go to state 9
    STRUCT      shift, and go to state 10
    TYPEDEF     shift, and go to state 11
    NUM         shift, and go to state 12
    ID          shift, and go to state 13
    LEFT_BRACE  shift, and go to state 14

    EOL         [reduce using rule 5 (stmts)]
    DO          [reduce using rule 5 (stmts)]
    FOR         [reduce using rule 5 (stmts)]
    RETURN      [reduce using rule 5 (stmts)]
    INT         [reduce using rule 5 (stmts)]
    FLOAT       [reduce using rule 5 (stmts)]
    DOUBLE      [reduce using rule 5 (stmts)]
    CHAR        [reduce using rule 5 (stmts)]
    VOID        [reduce using rule 5 (stmts)]
    STRUCT      [reduce using rule 5 (stmts)]
    TYPEDEF     [reduce using rule 5 (stmts)]
    NUM         [reduce using rule 5 (stmts)]
    ID          [reduce using rule 5 (stmts)]
    LEFT_BRACE  [reduce using rule 5 (stmts)]
    SEMI        reduce using rule 5 (stmts)
    SEMI        [reduce using rule 29 (if_stmt)]
    SEMI        [reduce using rule 31 (while_stmt)]
    $default    reduce using rule 5 (stmts)

    stmt              go to state 42
    declaration_stmt  go to state 18
    compound_stmt     go to state 19
    expr              go to state 20
    arith_expr        go to state 21
    if_stmt           go to state 22
    return_stmt       go to state 23
    while_stmt        go to state 24
    do_stmt           go to state 25
    for_stmt          go to state 26
    endofline         go to state 27
    type              go to state 28


State 61

    4 stmts: stmt SEMI endofline stmts •
    6      | stmts • stmt SEMI

    EOL         shift, and go to state 1
    DO          shift, and go to state 2
    FOR         shift, and go to state 3
    RETURN      shift, and go to state 4
    INT         shift, and go to state 5
    FLOAT       shift, and go to state 6
    DOUBLE      shift, and go to state 7
    CHAR        shift, and go to state 8
    VOID        shift, and go to state 9
    STRUCT      shift, and go to state 10
    TYPEDEF     shift, and go to state 11
    NUM         shift, and go to state 12
    ID          shift, and go to state 13
    LEFT_BRACE  shift, and go to state 14

    EOL         [reduce using rule 4 (stmts)]
    DO          [reduce using rule 4 (stmts)]
    FOR         [reduce using rule 4 (stmts)]
    RETURN      [reduce using rule 4 (stmts)]
    INT         [reduce using rule 4 (stmts)]
    FLOAT       [reduce using rule 4 (stmts)]
    DOUBLE      [reduce using rule 4 (stmts)]
    CHAR        [reduce using rule 4 (stmts)]
    VOID        [reduce using rule 4 (stmts)]
    STRUCT      [reduce using rule 4 (stmts)]
    TYPEDEF     [reduce using rule 4 (stmts)]
    NUM         [reduce using rule 4 (stmts)]
    ID          [reduce using rule 4 (stmts)]
    LEFT_BRACE  [reduce using rule 4 (stmts)]
    SEMI        reduce using rule 4 (stmts)
    SEMI        [reduce using rule 29 (if_stmt)]
    SEMI        [reduce using rule 31 (while_stmt)]
    $default    reduce using rule 4 (stmts)

    stmt              go to state 42
    declaration_stmt  go to state 18
    compound_stmt     go to state 19
    expr              go to state 20
    arith_expr        go to state 21
    if_stmt           go to state 22
    return_stmt       go to state 23
    while_stmt        go to state 24
    do_stmt           go to state 25
    for_stmt          go to state 26
    endofline         go to state 27
    type              go to state 28


State 62

   32 do_stmt: DO stmt WHILE LPAREN expr • RPAREN

    RPAREN  shift, and go to state 64


State 63

   33 for_stmt: FOR LPAREN expr SEMI expr • SEMI expr RPAREN stmt

    SEMI  shift, and go to state 65


State 64

   32 do_stmt: DO stmt WHILE LPAREN expr RPAREN •

    $default  reduce using rule 32 (do_stmt)


State 65

   33 for_stmt: FOR LPAREN expr SEMI expr SEMI • expr RPAREN stmt

    NUM  shift, and go to state 12
    ID   shift, and go to state 13

    expr        go to state 66
    arith_expr  go to state 21


State 66

   33 for_stmt: FOR LPAREN expr SEMI expr SEMI expr • RPAREN stmt

    RPAREN  shift, and go to state 67


State 67

   33 for_stmt: FOR LPAREN expr SEMI expr SEMI expr RPAREN • stmt

    EOL         shift, and go to state 1
    DO          shift, and go to state 2
    FOR         shift, and go to state 3
    RETURN      shift, and go to state 4
    INT         shift, and go to state 5
    FLOAT       shift, and go to state 6
    DOUBLE      shift, and go to state 7
    CHAR        shift, and go to state 8
    VOID        shift, and go to state 9
    STRUCT      shift, and go to state 10
    TYPEDEF     shift, and go to state 11
    NUM         shift, and go to state 12
    ID          shift, and go to state 13
    LEFT_BRACE  shift, and go to state 14

    WHILE     reduce using rule 29 (if_stmt)
    WHILE     [reduce using rule 31 (while_stmt)]
    SEMI      reduce using rule 29 (if_stmt)
    SEMI      [reduce using rule 31 (while_stmt)]
    $default  reduce using rule 29 (if_stmt)

    stmt              go to state 68
    declaration_stmt  go to state 18
    compound_stmt     go to state 19
    expr              go to state 20
    arith_expr        go to state 21
    if_stmt           go to state 22
    return_stmt       go to state 23
    while_stmt        go to state 24
    do_stmt           go to state 25
    for_stmt          go to state 26
    endofline         go to state 27
    type              go to state 28


State 68

   33 for_stmt: FOR LPAREN expr SEMI expr SEMI expr RPAREN stmt •

    $default  reduce using rule 33 (for_stmt)
